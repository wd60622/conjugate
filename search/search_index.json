{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Conjugate Models","text":"<p>Bayesian conjugate models in Python</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install conjugate-models\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>from conjugate.distributions import Beta, BetaBinomial\nfrom conjugate.models import binomial_beta, binomial_beta_posterior_predictive\n# Observed Data\nX = 4\nN = 10\n# Analytics\nprior = Beta(1, 1)\nprior_predictive: BetaBinomial = binomial_beta_posterior_predictive(n=N, beta=prior)\nposterior: Beta = binomial_beta(n=N, x=X, beta_prior=prior)\nposterior_predictive: BetaBinomial = binomial_beta_posterior_predictive(n=N, beta=posterior) \n# Figure\nimport matplotlib.pyplot as plt\nfig, axes = plt.subplots(ncols=2)\nax = axes[0]\nax = posterior.plot_pdf(ax=ax, label=\"posterior\")\nprior.plot_pdf(ax=ax, label=\"prior\")\nax.axvline(x=X/N, color=\"black\", ymax=0.05, label=\"MLE\")\nax.set_title(\"Success Rate\")\nax.legend()\nax = axes[1]\nposterior_predictive.plot_pmf(ax=ax, label=\"posterior predictive\")\nprior_predictive.plot_pmf(ax=ax, label=\"prior predictive\")\nax.axvline(x=X, color=\"black\", ymax=0.05, label=\"Sample\")\nax.set_title(\"Number of Successes\")\nax.legend()\nplt.show()\n</code></pre>"},{"location":"#additional-features","title":"Additional Features","text":""},{"location":"#vectorized-inputs","title":"Vectorized Inputs","text":"<p>All data and priors will allow for vectorized assuming the shapes work for broadcasting. </p> <p>The plotting also supports arrays of results</p> <pre><code>import numpy as np\n# Analytics \nprior = Beta(alpha=1, beta=np.array([1, 5]))\nposterior = binomial_beta(n=N, x=x, beta_prior=prior)\n# Figure\nax = prior.plot_pdf(label=lambda i: f\"prior {i}\")\nposterior.plot_pdf(ax=ax, label=lambda i: f\"posterior {i}\")\nax.axvline(x=x / N, ymax=0.05, color=\"black\", linestyle=\"--\", label=\"MLE\")\nax.legend()\nplt.show()\n</code></pre> <p></p>"},{"location":"#indexing-parameters","title":"Indexing Parameters","text":"<p>The distributions can be indexed for subsets. </p> <p><pre><code>beta = np.arange(1, 10)\nprior = Beta(alpha=1, beta=beta)\nidx = [0, 5, -1]\nprior_subset = prior[idx]\nprior_subset.plot_pdf(label = lambda i: f\"prior {i}\")\nplt.legend()\nplt.show()\n</code></pre> </p>"},{"location":"#generalized-numerical-inputs","title":"Generalized Numerical Inputs","text":"<p>Though the plotting is meant for numpy and python numbers, the conjugate models work with anything that works like numbers. </p> <p>For instance, Bayesian models in SQL using SQL Builder</p> <pre><code>from pypika import Field \n# Columns from table in database\nN = Field(\"total\")\nX = Field(\"successes\")\n# Conjugate prior\nprior = Beta(alpha=1, beta=1)\nposterior = binomial_beta(n=N, x=X, beta_prior=prior)\nprint(\"Posterior alpha:\", posterior.alpha)\nprint(\"Posterior beta:\", posterior.beta)\n# Posterior alpha: 1+\"successes\"\n# Posterior beta: 1+\"total\"-\"successes\"\n# Priors can be fields too\nalpha = Field(\"previous_successes\") - 1\nbeta = Field(\"previous_failures\") - 1\nprior = Beta(alpha=alpha, beta=beta)\nposterior = binomial_beta(n=N, x=X, beta_prior=prior)\nprint(\"Posterior alpha:\", posterior.alpha)\nprint(\"Posterior beta:\", posterior.beta)\n# Posterior alpha: \"previous_successes\"-1+\"successes\"\n# Posterior beta: \"previous_failures\"-1+\"total\"-\"successes\"\n</code></pre> <p>Using PyMC distributions for sampling with additional uncertainty</p> <pre><code>import pymc as pm \nalpha = pm.Gamma.dist(alpha=1, beta=20)\nbeta = pm.Gamma.dist(alpha=1, beta=20)\n# Observed Data\nN = 10\nX = 4\n# Conjugate prior \nprior = Beta(alpha=alpha, beta=beta)\nposterior = binomial_beta(n=N, x=X, beta_prior=prior)\n# Reconstruct the posterior distribution with PyMC\nprior_dist = pm.Beta.dist(alpha=prior.alpha, beta=prior.beta)\nposterior_dist = pm.Beta.dist(alpha=posterior.alpha, beta=posterior.beta)\nsamples = pm.draw([alpha, beta, prior_dist, posterior_dist], draws=1000)\n</code></pre>"},{"location":"#unsupported-posterior-predictive-distributions","title":"Unsupported Posterior Predictive Distributions","text":"<p>The geometric beta model posterior predictive doesn't have a common dist, but what doesn't mean the posterior predictive can be used. For instance, PyMC can be used to fill in this gap.</p> <pre><code>from conjugate.models import geometric_beta\nprior = Beta(1, 1)\nposterior: Beta = geometric_beta(x=1, n=10, beta_prior=prior)\nposterior_dist = pm.Beta.dist(alpha=posterior.alpha, beta=posterior.beta)\ngeometric_posterior_predictive = pm.Geometric.dist(posterior_dist)\nposterior_predictive_samples = pm.draw(geometric_posterior_predictive, draws=100)\n</code></pre>"},{"location":"#too-simple","title":"Too Simple?","text":"<p>Simple model, sure. Useful model, potentially.</p> <p>Constant probability of success, <code>p</code>, for <code>n</code> trials.</p> <pre><code>rng = np.random.default_rng(42)\n# Observed Data\nn_times = 75\np = np.repeat(0.5, n_times)\nsamples = rng.binomial(n=1, p=p, size=n_times)\n# Model\nn = np.arange(n_times) + 1\nprior = Beta(alpha=1, beta=1)\nposterior = binomial_beta(n=n, x=samples.cumsum(), beta_prior=prior)\n# Figure\nplt.plot(n, p, color=\"black\", label=\"true p\", linestyle=\"--\")\nplt.scatter(n, samples, color=\"black\", label=\"observed samples\")\nplt.plot(n, posterior.dist.mean(), color=\"red\", label=\"posterior mean\")\n# fill between the 95% credible interval\nplt.fill_between(\nn, \nposterior.dist.ppf(0.025),\nposterior.dist.ppf(0.975),\ncolor=\"red\",\nalpha=0.2,\nlabel=\"95% credible interval\",\n)\npadding = 0.025\nplt.ylim(0 - padding, 1 + padding)\nplt.xlim(1, n_times)\nplt.legend(loc=\"best\")\nplt.xlabel(\"Number of trials\")\nplt.ylabel(\"Probability\")\nplt.show()\n</code></pre> <p></p> <p>Even with a moving probability, this simple to implement model can be useful.</p> <pre><code>...\ndef sigmoid(x):\nreturn 1 / (1 + np.exp(-x))\np_raw = rng.normal(loc=0, scale=0.2, size=n_times).cumsum()\np = sigmoid(p_raw)\n...\n</code></pre> <p></p>"},{"location":"#resources","title":"Resources","text":"<ul> <li>Conjugate Priors</li> </ul>"},{"location":"distributions/","title":"Distributions","text":"<p>These are the supported distributions based on the conjugate models.</p> <p>Many have the <code>dist</code> attribute which is a scipy.stats distribution object. From there,  you can use the methods from scipy.stats to get the pdf, cdf, etc. <p>Distributions can be plotted using the <code>plot_pmf</code> or <code>plot_pdf</code> methods of the distribution.</p> <pre><code>from conjugate.distribution import Beta \nbeta = Beta(1, 1)\nscipy_dist = beta.dist \nprint(scipy_dist.mean())\n# 0.5\nprint(scipy_dist.ppf([0.025, 0.975]))\n# [0.025 0.975]\nsamples = scipy_dist.rvs(100)\nbeta.plot_pmf(label=\"beta distribution\")\n</code></pre> <p>Distributions like Poisson can be added with other Poissons or multiplied by numerical values in order to scale rate. For instance, </p> <pre><code>daily_rate = 0.25\ndaily_pois = Poisson(lam=daily_rate)\ntwo_day_pois = daily_pois + daily_pois\nweekly_pois = 7 * daily_pois\n</code></pre> <p>Below are the currently supported distributions</p>"},{"location":"distributions/#conjugate.distributions.Beta","title":"<code>Beta</code>  <code>dataclass</code>","text":"<p>         Bases: <code>ContinuousPlotDistMixin</code>, <code>SliceMixin</code></p> <p>Beta distribution.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>NUMERIC</code> <p>shape parameter</p> required <code>beta</code> <code>NUMERIC</code> <p>shape parameter</p> required Source code in <code>conjugate/distributions.py</code> <pre><code>@dataclass\nclass Beta(ContinuousPlotDistMixin, SliceMixin):\n\"\"\"Beta distribution.\n    Args: \n        alpha: shape parameter\n        beta: shape parameter\n    \"\"\"\nalpha: NUMERIC\nbeta: NUMERIC\ndef __post_init__(self) -&gt; None:\nself.max_value = 1.0\n@classmethod\ndef from_mean(cls, mean: float, alpha: float) -&gt; \"Beta\":\n\"\"\"Alternative constructor from mean and alpha.\"\"\"\nbeta = get_beta_param_from_mean_and_alpha(mean=mean, alpha=alpha)\nreturn cls(alpha=alpha, beta=beta)\n@classmethod\ndef from_successes_and_failures(cls, successes: int, failures: int) -&gt; \"Beta\":\n\"\"\"Alternative constructor based on hyperparameter interpretation.\"\"\"\nalpha = successes + 1\nbeta = failures + 1\nreturn cls(alpha=alpha, beta=beta)\n@property\ndef dist(self):\nreturn stats.beta(self.alpha, self.beta)\n</code></pre>"},{"location":"distributions/#conjugate.distributions.Beta.from_mean","title":"<code>from_mean(mean, alpha)</code>  <code>classmethod</code>","text":"<p>Alternative constructor from mean and alpha.</p> Source code in <code>conjugate/distributions.py</code> <pre><code>@classmethod\ndef from_mean(cls, mean: float, alpha: float) -&gt; \"Beta\":\n\"\"\"Alternative constructor from mean and alpha.\"\"\"\nbeta = get_beta_param_from_mean_and_alpha(mean=mean, alpha=alpha)\nreturn cls(alpha=alpha, beta=beta)\n</code></pre>"},{"location":"distributions/#conjugate.distributions.Beta.from_successes_and_failures","title":"<code>from_successes_and_failures(successes, failures)</code>  <code>classmethod</code>","text":"<p>Alternative constructor based on hyperparameter interpretation.</p> Source code in <code>conjugate/distributions.py</code> <pre><code>@classmethod\ndef from_successes_and_failures(cls, successes: int, failures: int) -&gt; \"Beta\":\n\"\"\"Alternative constructor based on hyperparameter interpretation.\"\"\"\nalpha = successes + 1\nbeta = failures + 1\nreturn cls(alpha=alpha, beta=beta)\n</code></pre>"},{"location":"distributions/#conjugate.distributions.BetaBinomial","title":"<code>BetaBinomial</code>  <code>dataclass</code>","text":"<p>         Bases: <code>DiscretePlotMixin</code>, <code>SliceMixin</code></p> <p>Beta binomial distribution.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>NUMERIC</code> <p>number of trials</p> required <code>alpha</code> <code>NUMERIC</code> <p>shape parameter</p> required <code>beta</code> <code>NUMERIC</code> <p>shape parameter</p> required Source code in <code>conjugate/distributions.py</code> <pre><code>@dataclass\nclass BetaBinomial(DiscretePlotMixin, SliceMixin):\n\"\"\"Beta binomial distribution.\n    Args:\n        n: number of trials\n        alpha: shape parameter\n        beta: shape parameter\n    \"\"\"\nn: NUMERIC\nalpha: NUMERIC\nbeta: NUMERIC\ndef __post_init__(self):\nif isinstance(self.n, np.ndarray):\nself.max_value = self.n.max()\nelse:\nself.max_value = self.n\n@property\ndef dist(self):\nreturn stats.betabinom(self.n, self.alpha, self.beta)\n</code></pre>"},{"location":"distributions/#conjugate.distributions.BetaNegativeBinomial","title":"<code>BetaNegativeBinomial</code>  <code>dataclass</code>","text":"<p>         Bases: <code>SliceMixin</code></p> <p>Beta negative binomial distribution.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>NUMERIC</code> <p>number of successes</p> required <code>alpha</code> <code>NUMERIC</code> <p>shape parameter</p> required Source code in <code>conjugate/distributions.py</code> <pre><code>@dataclass\nclass BetaNegativeBinomial(SliceMixin):\n\"\"\"Beta negative binomial distribution.\n    Args:\n        n: number of successes\n        alpha: shape parameter\n    \"\"\"\nn: NUMERIC\nalpha: NUMERIC\nbeta: NUMERIC\n</code></pre>"},{"location":"distributions/#conjugate.distributions.Dirichlet","title":"<code>Dirichlet</code>  <code>dataclass</code>","text":"<p>         Bases: <code>DirichletPlotDistMixin</code></p> <p>Dirichlet distribution.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>NUMERIC</code> <p>shape parameter</p> required Source code in <code>conjugate/distributions.py</code> <pre><code>@dataclass\nclass Dirichlet(DirichletPlotDistMixin):\n\"\"\"Dirichlet distribution.\n    Args: \n        alpha: shape parameter\n    \"\"\"\nalpha: NUMERIC\ndef __post_init__(self) -&gt; None:\nself.max_value = 1.0\n@property\ndef dist(self):\nif self.alpha.ndim == 1:\nreturn stats.dirichlet(self.alpha)\nreturn VectorizedDist(self.alpha, dist=stats.dirichlet)\n</code></pre>"},{"location":"distributions/#conjugate.distributions.Exponential","title":"<code>Exponential</code>  <code>dataclass</code>","text":"<p>         Bases: <code>ContinuousPlotDistMixin</code>, <code>SliceMixin</code></p> <p>Exponential distribution.</p> <p>Parameters:</p> Name Type Description Default <code>lam</code> <code>NUMERIC</code> <p>rate parameter</p> required Source code in <code>conjugate/distributions.py</code> <pre><code>@dataclass\nclass Exponential(ContinuousPlotDistMixin, SliceMixin):\n\"\"\"Exponential distribution.\n    Args: \n        lam: rate parameter\n    \"\"\"\nlam: NUMERIC\n@property\ndef dist(self):\nreturn stats.expon(scale=self.lam)\n</code></pre>"},{"location":"distributions/#conjugate.distributions.Gamma","title":"<code>Gamma</code>  <code>dataclass</code>","text":"<p>         Bases: <code>ContinuousPlotDistMixin</code>, <code>SliceMixin</code></p> <p>Gamma distribution.</p> <p>Gamma Distribution Scipy Docmentation</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>NUMERIC</code> <p>shape parameter</p> required <code>beta</code> <code>NUMERIC</code> <p>rate parameter</p> required Source code in <code>conjugate/distributions.py</code> <pre><code>@dataclass\nclass Gamma(ContinuousPlotDistMixin, SliceMixin):\n\"\"\"Gamma distribution.\n    &lt;a href=https://en.wikipedia.org/wiki/Gamma_distribution&gt;Gamma Distribution&lt;/a&gt;\n    &lt;a href=https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gamma.html&gt;Scipy Docmentation&lt;/a&gt;\n    Args: \n        alpha: shape parameter\n        beta: rate parameter\n    \"\"\"\nalpha: NUMERIC\nbeta: NUMERIC\n@property\ndef dist(self):\nreturn stats.gamma(a=self.alpha, scale=1 / self.beta)\ndef __mul__(self, other):\nreturn Gamma(alpha=self.alpha * other, beta=self.beta)\n__rmul__ = __mul__\n</code></pre>"},{"location":"distributions/#conjugate.distributions.Geometric","title":"<code>Geometric</code>  <code>dataclass</code>","text":"<p>         Bases: <code>DiscretePlotMixin</code>, <code>SliceMixin</code></p> <p>Geometric distribution.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>NUMERIC</code> <p>probability of success</p> required Source code in <code>conjugate/distributions.py</code> <pre><code>@dataclass\nclass Geometric(DiscretePlotMixin, SliceMixin):\n\"\"\"Geometric distribution.\n    Args:\n        p: probability of success\n    \"\"\"\np: NUMERIC\n@property\ndef dist(self):\nreturn stats.geom(self.p)\n</code></pre>"},{"location":"distributions/#conjugate.distributions.NegativeBinomial","title":"<code>NegativeBinomial</code>  <code>dataclass</code>","text":"<p>         Bases: <code>DiscretePlotMixin</code>, <code>SliceMixin</code></p> <p>Negative binomial distribution.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>NUMERIC</code> <p>number of successes</p> required <code>p</code> <code>NUMERIC</code> <p>probability of success</p> required Source code in <code>conjugate/distributions.py</code> <pre><code>@dataclass\nclass NegativeBinomial(DiscretePlotMixin, SliceMixin):\n\"\"\"Negative binomial distribution.\n    Args: \n        n: number of successes\n        p: probability of success\n    \"\"\"\nn: NUMERIC\np: NUMERIC\n@property\ndef dist(self):\nreturn stats.nbinom(n=self.n, p=self.p)\ndef __mul__(self, other):\nreturn NegativeBinomial(n=self.n * other, p=self.p)\n__rmul__ = __mul__\n</code></pre>"},{"location":"distributions/#conjugate.distributions.Poisson","title":"<code>Poisson</code>  <code>dataclass</code>","text":"<p>         Bases: <code>DiscretePlotMixin</code>, <code>SliceMixin</code></p> <p>Poisson distribution.</p> <p>Parameters:</p> Name Type Description Default <code>lam</code> <code>NUMERIC</code> <p>rate parameter</p> required Source code in <code>conjugate/distributions.py</code> <pre><code>@dataclass\nclass Poisson(DiscretePlotMixin, SliceMixin):\n\"\"\"Poisson distribution.\n    Args:\n        lam: rate parameter\n    \"\"\"\nlam: NUMERIC\n@property\ndef dist(self):\nreturn stats.poisson(self.lam)\ndef __mul__(self, other) -&gt; \"Poisson\":\nreturn Poisson(lam=self.lam * other)\n__rmul__ = __mul__\ndef __add__(self, other) -&gt; \"Poisson\": \nreturn Poisson(self.lam + other.lam)\n__radd__ = __add__\n</code></pre>"},{"location":"mixins/","title":"Mixins","text":"<p>Two sets of mixins to support the plotting and slicing of the distribution parameters</p>"},{"location":"mixins/#conjugate.plot.ContinuousPlotDistMixin","title":"<code>ContinuousPlotDistMixin</code>","text":"<p>         Bases: <code>PlotDistMixin</code></p> <p>Functionality for plot_pdf method of continuous distributions.</p> Source code in <code>conjugate/plot.py</code> <pre><code>class ContinuousPlotDistMixin(PlotDistMixin):\n\"\"\"Functionality for plot_pdf method of continuous distributions.\"\"\"\ndef plot_pdf(self, ax: Optional[plt.Axes] = None, **kwargs) -&gt; plt.Axes:\n\"\"\"Plot the pdf of distribution\n        Args: \n            ax: matplotlib Axes, optional\n            **kwargs: Additonal kwargs to pass to matplotlib\n        Returns: \n            new or modified Axes\n        \"\"\"\nax = self._settle_axis(ax=ax)\nx = self._create_x_values()\nx = self._reshape_x_values(x)\nreturn self._create_plot_on_axis(x, ax, **kwargs)\ndef _create_x_values(self) -&gt; np.ndarray:\nreturn np.linspace(0, self.max_value, 100)\ndef _setup_labels(self, ax) -&gt; None:\nax.set_xlabel(\"Domain\")\nax.set_ylabel(\"Density $f(x)$\")\ndef _create_plot_on_axis(self, x, ax, **kwargs) -&gt; plt.Axes:\nyy = self.dist.pdf(x)\nif \"label\" in kwargs:\nlabel = kwargs.pop(\"label\")\nlabel = self._resolve_label(label, yy)\nelse:\nlabel = None\nax.plot(x, yy, label=label, **kwargs)\nself._setup_labels(ax=ax)\nax.set_ylim(0, None)\nreturn ax\n</code></pre>"},{"location":"mixins/#conjugate.plot.ContinuousPlotDistMixin.plot_pdf","title":"<code>plot_pdf(ax=None, **kwargs)</code>","text":"<p>Plot the pdf of distribution</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Optional[plt.Axes]</code> <p>matplotlib Axes, optional</p> <code>None</code> <code>**kwargs</code> <p>Additonal kwargs to pass to matplotlib</p> <code>{}</code> <p>Returns:</p> Type Description <code>plt.Axes</code> <p>new or modified Axes</p> Source code in <code>conjugate/plot.py</code> <pre><code>def plot_pdf(self, ax: Optional[plt.Axes] = None, **kwargs) -&gt; plt.Axes:\n\"\"\"Plot the pdf of distribution\n    Args: \n        ax: matplotlib Axes, optional\n        **kwargs: Additonal kwargs to pass to matplotlib\n    Returns: \n        new or modified Axes\n    \"\"\"\nax = self._settle_axis(ax=ax)\nx = self._create_x_values()\nx = self._reshape_x_values(x)\nreturn self._create_plot_on_axis(x, ax, **kwargs)\n</code></pre>"},{"location":"mixins/#conjugate.plot.DirichletPlotDistMixin","title":"<code>DirichletPlotDistMixin</code>","text":"<p>         Bases: <code>ContinuousPlotDistMixin</code></p> <p>Plot the pdf using samples from the dirichlet distribution.</p> Source code in <code>conjugate/plot.py</code> <pre><code>class DirichletPlotDistMixin(ContinuousPlotDistMixin):\n\"\"\"Plot the pdf using samples from the dirichlet distribution.\"\"\"\ndef plot_pdf(\nself, ax: Optional[plt.Axes] = None, samples: int = 1_000, **kwargs\n) -&gt; plt.Axes:\n\"\"\"Plots the pdf \"\"\"\ndistribution_samples = self.dist.rvs(size=samples)\nax = self._settle_axis(ax=ax)\nxx = self._create_x_values()\nfor x in distribution_samples.T:\nkde = gaussian_kde(x)\nyy = kde(xx)\nax.plot(xx, yy)\nself._setup_labels(ax=ax)\nreturn ax\n</code></pre>"},{"location":"mixins/#conjugate.plot.DirichletPlotDistMixin.plot_pdf","title":"<code>plot_pdf(ax=None, samples=1000, **kwargs)</code>","text":"<p>Plots the pdf</p> Source code in <code>conjugate/plot.py</code> <pre><code>def plot_pdf(\nself, ax: Optional[plt.Axes] = None, samples: int = 1_000, **kwargs\n) -&gt; plt.Axes:\n\"\"\"Plots the pdf \"\"\"\ndistribution_samples = self.dist.rvs(size=samples)\nax = self._settle_axis(ax=ax)\nxx = self._create_x_values()\nfor x in distribution_samples.T:\nkde = gaussian_kde(x)\nyy = kde(xx)\nax.plot(xx, yy)\nself._setup_labels(ax=ax)\nreturn ax\n</code></pre>"},{"location":"mixins/#conjugate.plot.DiscretePlotMixin","title":"<code>DiscretePlotMixin</code>","text":"<p>         Bases: <code>PlotDistMixin</code></p> <p>Adding the plot_pmf method to class.</p> Source code in <code>conjugate/plot.py</code> <pre><code>class DiscretePlotMixin(PlotDistMixin):\n\"\"\"Adding the plot_pmf method to class.\"\"\"\ndef plot_pmf(\nself, ax: Optional[plt.Axes] = None, mark: str = \"o-\", **kwargs\n) -&gt; plt.Axes:\nax = self._settle_axis(ax=ax)\nx = self._create_x_values()\nx = self._reshape_x_values(x)\nreturn self._create_plot_on_axis(x, ax, mark, **kwargs)\ndef _create_x_values(self) -&gt; np.ndarray:\nreturn np.arange(0, self.max_value + 1, 1)\ndef _create_plot_on_axis(self, x, ax, mark, **kwargs) -&gt; plt.Axes:\nyy = self.dist.pmf(x)\nif \"label\" in kwargs:\nlabel = kwargs.pop(\"label\")\nlabel = self._resolve_label(label, yy)\nelse:\nlabel = None\nax.plot(x, yy, mark, label=label, **kwargs)\nif self.max_value &lt;= 15:\nax.set_xticks(x.ravel())\nax.set_xlabel(\"Domain\")\nax.set_ylabel(\"Probability $f(x)$\")\nax.set_ylim(0, None)\nreturn ax\n</code></pre>"},{"location":"mixins/#conjugate.plot.PlotDistMixin","title":"<code>PlotDistMixin</code>","text":"<p>Base mixin in order to support plotting. Requires the dist attribute of the scipy distribution.</p> Source code in <code>conjugate/plot.py</code> <pre><code>class PlotDistMixin:\n\"\"\"Base mixin in order to support plotting. Requires the dist attribute of the scipy distribution.\"\"\"\n@property\ndef dist(self) -&gt; Distribution:\nraise NotImplementedError(\"Implement this property in the subclass.\")\n@property\ndef max_value(self) -&gt; float:\nif not hasattr(self, \"_max_value\"):\nraise ValueError(\"Set the max value before plotting.\")\nreturn self._max_value\n@max_value.setter\ndef max_value(self, value: float) -&gt; None:\nself._max_value = value\ndef set_max_value(self, value: float) -&gt; \"PlotDistMixin\":\nself.max_value = value\nreturn self\ndef _reshape_x_values(self, x: np.ndarray) -&gt; np.ndarray:\n\"\"\"Make sure that the values are ready for plotting.\"\"\"\nfor value in asdict(self).values():\nif not isinstance(value, float):\nreturn x[:, None]\nreturn x\ndef _resolve_label(self, label: LABEL_INPUT, yy: np.ndarray):\n\"\"\"\n        https://stackoverflow.com/questions/73662931/matplotlib-plot-a-numpy-array-as-many-lines-with-a-single-label\n        \"\"\"\nif yy.ndim == 1:\nreturn label\nncols = yy.shape[1]\nif ncols != 1:\nif isinstance(label, Iterable):\nreturn label\nif isinstance(label, str):\nlabel = lambda i: f\"{label} {i}\"\nif callable(label):\nreturn [label(i) for i in range(1, ncols + 1)]\nraise ValueError(\"Label must be a string, iterable, or callable.\")\nreturn label\ndef _settle_axis(self, ax: Optional[plt.Axes] = None) -&gt; plt.Axes:\nreturn ax if ax is not None else plt.gca()\n</code></pre>"},{"location":"mixins/#conjugate.slice.SliceMixin","title":"<code>SliceMixin</code>","text":"<p>Mixin in order to slice the parameters</p> Source code in <code>conjugate/slice.py</code> <pre><code>class SliceMixin:\n\"\"\"Mixin in order to slice the parameters\"\"\"\ndef __getitem__(self, key):\nparams = asdict(self)\ndef slice(value, key):\ntry:\nreturn value[key]\nexcept Exception:\nreturn value\nnew_params = {k: slice(value=v, key=key) for k, v in params.items()}\nreturn self.__class__(**new_params)\n</code></pre>"},{"location":"models/","title":"Models","text":"<p>For more on these models, check out the Conjugate Prior Wikipedia Table</p> <p>Below are the supported models</p>"},{"location":"models/#conjugate.models.binomial_beta","title":"<code>binomial_beta(n, x, beta_prior)</code>","text":"<p>Posterior distribution for a binomial likelihood with a beta prior. </p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>NUMERIC</code> <p>total number of trials </p> required <code>x</code> <code>NUMERIC</code> <p>sucesses from that trials</p> required <code>beta_prior</code> <code>Beta</code> <p>Beta distribution prior</p> required <p>Returns:</p> Type Description <code>Beta</code> <p>Beta distribution posterior</p> Source code in <code>conjugate/models.py</code> <pre><code>def binomial_beta(n: NUMERIC, x: NUMERIC, beta_prior: Beta) -&gt; Beta:\n\"\"\"Posterior distribution for a binomial likelihood with a beta prior. \n    Args: \n        n: total number of trials \n        x: sucesses from that trials\n        beta_prior: Beta distribution prior\n    Returns: \n        Beta distribution posterior\n    \"\"\"\nalpha_post, beta_post = get_binomial_beta_posterior_params(\nbeta_prior.alpha, beta_prior.beta, n, x\n)\nreturn Beta(alpha=alpha_post, beta=beta_post)\n</code></pre>"},{"location":"models/#conjugate.models.binomial_beta_posterior_predictive","title":"<code>binomial_beta_posterior_predictive(n, beta)</code>","text":"<p>Posterior predictive distribution for a binomial likelihood with a beta prior. </p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>NUMERIC</code> <p>number of trials</p> required <code>beta</code> <code>Beta</code> <p>Beta distribution</p> required <p>Returns:</p> Type Description <code>BetaBinomial</code> <p>BetaBinomial posterior predictive distribution</p> Source code in <code>conjugate/models.py</code> <pre><code>def binomial_beta_posterior_predictive(n: NUMERIC, beta: Beta) -&gt; BetaBinomial:\n\"\"\"Posterior predictive distribution for a binomial likelihood with a beta prior. \n    Args: \n        n: number of trials\n        beta: Beta distribution\n    Returns: \n        BetaBinomial posterior predictive distribution\n    \"\"\"\nreturn BetaBinomial(n=n, alpha=beta.alpha, beta=beta.beta)\n</code></pre>"},{"location":"models/#conjugate.models.geometric_beta","title":"<code>geometric_beta(x, n, beta_prior)</code>","text":"<p>Posterior distribution for a geometric likelihood with a beta prior</p> Source code in <code>conjugate/models.py</code> <pre><code>def geometric_beta(x, n, beta_prior: Beta) -&gt; Beta:\n\"\"\"Posterior distribution for a geometric likelihood with a beta prior\"\"\"\nalpha_post = beta_prior.alpha + n\nbeta_post = beta_prior.beta + x\nreturn Beta(alpha=alpha_post, beta=beta_post)\n</code></pre>"},{"location":"models/#conjugate.models.negative_binomial_beta","title":"<code>negative_binomial_beta(r, n, x, beta_prior)</code>","text":"<p>Posterior distribution for a negative binomial likelihood with a beta prior. </p> Source code in <code>conjugate/models.py</code> <pre><code>def negative_binomial_beta(r, n, x, beta_prior: Beta) -&gt; Beta:\n\"\"\"Posterior distribution for a negative binomial likelihood with a beta prior. \n    Args: \n    \"\"\"\nalpha_post = beta_prior.alpha + (r * n)\nbeta_post = beta_prior.beta + x\nreturn Beta(alpha=alpha_post, beta=beta_post)\n</code></pre>"},{"location":"models/#conjugate.models.negative_binomial_beta_posterior_predictive","title":"<code>negative_binomial_beta_posterior_predictive(r, beta)</code>","text":"<p>Posterior predictive distribution for a negative binomial likelihood with a beta prior</p> Source code in <code>conjugate/models.py</code> <pre><code>def negative_binomial_beta_posterior_predictive(r, beta: Beta) -&gt; BetaNegativeBinomial:\n\"\"\"Posterior predictive distribution for a negative binomial likelihood with a beta prior\"\"\"\nreturn BetaNegativeBinomial(r=r, alpha=beta.alpha, beta=beta.beta)\n</code></pre>"},{"location":"models/#conjugate.models.poisson_gamma","title":"<code>poisson_gamma(x_total, n, gamma_prior)</code>","text":"<p>Posterior distribution for a poisson likelihood with a gamma prior</p> Source code in <code>conjugate/models.py</code> <pre><code>def poisson_gamma(x_total: NUMERIC, n: NUMERIC, gamma_prior: Gamma) -&gt; Gamma:\n\"\"\"Posterior distribution for a poisson likelihood with a gamma prior\"\"\"\nalpha_post, beta_post = get_poisson_gamma_posterior_params(\nalpha=gamma_prior.alpha, beta=gamma_prior.beta, x_total=x_total, n=n\n)\nreturn Gamma(alpha=alpha_post, beta=beta_post)\n</code></pre>"},{"location":"models/#conjugate.models.poisson_gamma_posterior_predictive","title":"<code>poisson_gamma_posterior_predictive(gamma, n=1)</code>","text":"<p>Posterior predictive distribution for a poisson likelihood with a gamma prior</p> <p>Parameters:</p> Name Type Description Default <code>gamma</code> <code>Gamma</code> <p>Gamma distribution</p> required <code>n</code> <code>NUMERIC</code> <p>Number of trials for each sample, defaults to 1. Can be used to scale the distributions to a different unit of time.</p> <code>1</code> <p>Returns:</p> Type Description <code>NegativeBinomial</code> <p>NegativeBinomial distribution related to posterior predictive</p> Source code in <code>conjugate/models.py</code> <pre><code>def poisson_gamma_posterior_predictive(\ngamma: Gamma, n: NUMERIC = 1\n) -&gt; NegativeBinomial:\n\"\"\"Posterior predictive distribution for a poisson likelihood with a gamma prior\n    Args:\n        gamma: Gamma distribution\n        n: Number of trials for each sample, defaults to 1.\n            Can be used to scale the distributions to a different unit of time.\n    Returns:\n        NegativeBinomial distribution related to posterior predictive\n    \"\"\"\nn = n * gamma.alpha\np = gamma.beta / (1 + gamma.beta)\nreturn NegativeBinomial(n=n, p=p)\n</code></pre>"}]}