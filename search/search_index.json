{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Conjugate Models","text":"<p>Bayesian conjugate models in Python</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install conjugate-models\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>from conjugate.distributions import Beta, BetaBinomial\nfrom conjugate.models import binomial_beta, binomial_beta_posterior_predictive\n# Observed Data\nX = 4\nN = 10\n# Analytics\nprior = Beta(1, 1)\nprior_predictive: BetaBinomial = binomial_beta_posterior_predictive(n=N, beta=prior)\nposterior: Beta = binomial_beta(n=N, x=X, beta_prior=prior)\nposterior_predictive: BetaBinomial = binomial_beta_posterior_predictive(n=N, beta=posterior) \n# Figure\nimport matplotlib.pyplot as plt\nfig, axes = plt.subplots(ncols=2)\nax = axes[0]\nax = posterior.plot_pdf(ax=ax, label=\"posterior\")\nprior.plot_pdf(ax=ax, label=\"prior\")\nax.axvline(x=X/N, color=\"black\", ymax=0.05, label=\"MLE\")\nax.set_title(\"Success Rate\")\nax.legend()\nax = axes[1]\nposterior_predictive.plot_pmf(ax=ax, label=\"posterior predictive\")\nprior_predictive.plot_pmf(ax=ax, label=\"prior predictive\")\nax.axvline(x=X, color=\"black\", ymax=0.05, label=\"Sample\")\nax.set_title(\"Number of Successes\")\nax.legend()\nplt.show()\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Connection to Scipy Distributions with <code>dist</code> attribute</li> <li>Built in Plotting with <code>plot_pdf</code> and <code>plot_pmf</code> methods</li> <li>Vectorized Operations for parameters and data</li> <li>Indexing Parameters for subsetting and slicing</li> <li>Generalized Numerical Inputs for inputs other than builtins and numpy arrays</li> <li>Unsupported Distributions for sampling from unsupported distributions</li> </ul>"},{"location":"#too-simple","title":"Too Simple?","text":"<p>Simple model, sure. Useful model, potentially.</p> <p>Constant probability of success, <code>p</code>, for <code>n</code> trials.</p> <pre><code>rng = np.random.default_rng(42)\n# Observed Data\nn_times = 75\np = np.repeat(0.5, n_times)\nsamples = rng.binomial(n=1, p=p, size=n_times)\n# Model\nn = np.arange(n_times) + 1\nprior = Beta(alpha=1, beta=1)\nposterior = binomial_beta(n=n, x=samples.cumsum(), beta_prior=prior)\n# Figure\nplt.plot(n, p, color=\"black\", label=\"true p\", linestyle=\"--\")\nplt.scatter(n, samples, color=\"black\", label=\"observed samples\")\nplt.plot(n, posterior.dist.mean(), color=\"red\", label=\"posterior mean\")\n# fill between the 95% credible interval\nplt.fill_between(\nn, \nposterior.dist.ppf(0.025),\nposterior.dist.ppf(0.975),\ncolor=\"red\",\nalpha=0.2,\nlabel=\"95% credible interval\",\n)\npadding = 0.025\nplt.ylim(0 - padding, 1 + padding)\nplt.xlim(1, n_times)\nplt.legend(loc=\"best\")\nplt.xlabel(\"Number of trials\")\nplt.ylabel(\"Probability\")\nplt.show()\n</code></pre> <p></p> <p>Even with a moving probability, this simple to implement model can be useful.</p> <pre><code>...\ndef sigmoid(x):\nreturn 1 / (1 + np.exp(-x))\np_raw = rng.normal(loc=0, scale=0.2, size=n_times).cumsum()\np = sigmoid(p_raw)\n...\n</code></pre> <p></p>"},{"location":"#resources","title":"Resources","text":"<ul> <li>Conjugate Priors</li> </ul>"},{"location":"distributions/","title":"Distributions","text":"<p>These are the supported distributions based on the conjugate models.</p> <p>Many have the <code>dist</code> attribute which is a scipy.stats distribution object. From there,  you can use the methods from scipy.stats to get the pdf, cdf, etc.</p> <p>Distributions can be plotted using the <code>plot_pmf</code> or <code>plot_pdf</code> methods of the distribution.</p> <pre><code>from conjugate.distribution import Beta \nbeta = Beta(1, 1)\nscipy_dist = beta.dist \nprint(scipy_dist.mean())\n# 0.5\nprint(scipy_dist.ppf([0.025, 0.975]))\n# [0.025 0.975]\nsamples = scipy_dist.rvs(100)\nbeta.plot_pmf(label=\"beta distribution\")\n</code></pre> <p>Distributions like Poisson can be added with other Poissons or multiplied by numerical values in order to scale rate. For instance, </p> <pre><code>daily_rate = 0.25\ndaily_pois = Poisson(lam=daily_rate)\ntwo_day_pois = daily_pois + daily_pois\nweekly_pois = 7 * daily_pois\n</code></pre> <p>Below are the currently supported distributions</p>"},{"location":"distributions/#conjugate.distributions.Beta","title":"<code>Beta</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ContinuousPlotDistMixin</code>, <code>SliceMixin</code></p> <p>Beta distribution.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>NUMERIC</code> <p>shape parameter</p> required <code>beta</code> <code>NUMERIC</code> <p>shape parameter</p> required Source code in <code>conjugate/distributions.py</code> <pre><code>@dataclass\nclass Beta(ContinuousPlotDistMixin, SliceMixin):\n\"\"\"Beta distribution.\n    Args:\n        alpha: shape parameter\n        beta: shape parameter\n    \"\"\"\nalpha: NUMERIC\nbeta: NUMERIC\ndef __post_init__(self) -&gt; None:\nself.max_value = 1.0\n@classmethod\ndef from_mean(cls, mean: float, alpha: float) -&gt; \"Beta\":\n\"\"\"Alternative constructor from mean and alpha.\"\"\"\nbeta = get_beta_param_from_mean_and_alpha(mean=mean, alpha=alpha)\nreturn cls(alpha=alpha, beta=beta)\n@classmethod\ndef from_successes_and_failures(cls, successes: int, failures: int) -&gt; \"Beta\":\n\"\"\"Alternative constructor based on hyperparameter interpretation.\"\"\"\nalpha = successes + 1\nbeta = failures + 1\nreturn cls(alpha=alpha, beta=beta)\n@property\ndef dist(self):\nreturn stats.beta(self.alpha, self.beta)\n</code></pre>"},{"location":"distributions/#conjugate.distributions.Beta.from_mean","title":"<code>from_mean(mean, alpha)</code>  <code>classmethod</code>","text":"<p>Alternative constructor from mean and alpha.</p> Source code in <code>conjugate/distributions.py</code> <pre><code>@classmethod\ndef from_mean(cls, mean: float, alpha: float) -&gt; \"Beta\":\n\"\"\"Alternative constructor from mean and alpha.\"\"\"\nbeta = get_beta_param_from_mean_and_alpha(mean=mean, alpha=alpha)\nreturn cls(alpha=alpha, beta=beta)\n</code></pre>"},{"location":"distributions/#conjugate.distributions.Beta.from_successes_and_failures","title":"<code>from_successes_and_failures(successes, failures)</code>  <code>classmethod</code>","text":"<p>Alternative constructor based on hyperparameter interpretation.</p> Source code in <code>conjugate/distributions.py</code> <pre><code>@classmethod\ndef from_successes_and_failures(cls, successes: int, failures: int) -&gt; \"Beta\":\n\"\"\"Alternative constructor based on hyperparameter interpretation.\"\"\"\nalpha = successes + 1\nbeta = failures + 1\nreturn cls(alpha=alpha, beta=beta)\n</code></pre>"},{"location":"distributions/#conjugate.distributions.BetaBinomial","title":"<code>BetaBinomial</code>  <code>dataclass</code>","text":"<p>             Bases: <code>DiscretePlotMixin</code>, <code>SliceMixin</code></p> <p>Beta binomial distribution.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>NUMERIC</code> <p>number of trials</p> required <code>alpha</code> <code>NUMERIC</code> <p>shape parameter</p> required <code>beta</code> <code>NUMERIC</code> <p>shape parameter</p> required Source code in <code>conjugate/distributions.py</code> <pre><code>@dataclass\nclass BetaBinomial(DiscretePlotMixin, SliceMixin):\n\"\"\"Beta binomial distribution.\n    Args:\n        n: number of trials\n        alpha: shape parameter\n        beta: shape parameter\n    \"\"\"\nn: NUMERIC\nalpha: NUMERIC\nbeta: NUMERIC\ndef __post_init__(self):\nif isinstance(self.n, np.ndarray):\nself.max_value = self.n.max()\nelse:\nself.max_value = self.n\n@property\ndef dist(self):\nreturn stats.betabinom(self.n, self.alpha, self.beta)\n</code></pre>"},{"location":"distributions/#conjugate.distributions.BetaNegativeBinomial","title":"<code>BetaNegativeBinomial</code>  <code>dataclass</code>","text":"<p>             Bases: <code>SliceMixin</code></p> <p>Beta negative binomial distribution.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>NUMERIC</code> <p>number of successes</p> required <code>alpha</code> <code>NUMERIC</code> <p>shape parameter</p> required Source code in <code>conjugate/distributions.py</code> <pre><code>@dataclass\nclass BetaNegativeBinomial(SliceMixin):\n\"\"\"Beta negative binomial distribution.\n    Args:\n        n: number of successes\n        alpha: shape parameter\n    \"\"\"\nn: NUMERIC\nalpha: NUMERIC\nbeta: NUMERIC\n</code></pre>"},{"location":"distributions/#conjugate.distributions.Binomial","title":"<code>Binomial</code>  <code>dataclass</code>","text":"<p>             Bases: <code>DiscretePlotMixin</code>, <code>SliceMixin</code></p> <p>Binomial distribution.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>NUMERIC</code> <p>number of trials</p> required <code>p</code> <code>NUMERIC</code> <p>probability of success</p> required Source code in <code>conjugate/distributions.py</code> <pre><code>@dataclass\nclass Binomial(DiscretePlotMixin, SliceMixin):\n\"\"\"Binomial distribution.\n    Args:\n        n: number of trials\n        p: probability of success\n    \"\"\"\nn: NUMERIC\np: NUMERIC\ndef __post_init__(self):\nif isinstance(self.n, np.ndarray):\nself.max_value = self.n.max()\nelse:\nself.max_value = self.n\n@property\ndef dist(self):\nreturn stats.binom(n=self.n, p=self.p)\n</code></pre>"},{"location":"distributions/#conjugate.distributions.Dirichlet","title":"<code>Dirichlet</code>  <code>dataclass</code>","text":"<p>             Bases: <code>DirichletPlotDistMixin</code></p> <p>Dirichlet distribution.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>NUMERIC</code> <p>shape parameter</p> required Source code in <code>conjugate/distributions.py</code> <pre><code>@dataclass\nclass Dirichlet(DirichletPlotDistMixin):\n\"\"\"Dirichlet distribution.\n    Args:\n        alpha: shape parameter\n    \"\"\"\nalpha: NUMERIC\ndef __post_init__(self) -&gt; None:\nself.max_value = 1.0\n@property\ndef dist(self):\nif self.alpha.ndim == 1:\nreturn stats.dirichlet(self.alpha)\nreturn VectorizedDist(self.alpha, dist=stats.dirichlet)\n</code></pre>"},{"location":"distributions/#conjugate.distributions.Exponential","title":"<code>Exponential</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ContinuousPlotDistMixin</code>, <code>SliceMixin</code></p> <p>Exponential distribution.</p> <p>Parameters:</p> Name Type Description Default <code>lam</code> <code>NUMERIC</code> <p>rate parameter</p> required Source code in <code>conjugate/distributions.py</code> <pre><code>@dataclass\nclass Exponential(ContinuousPlotDistMixin, SliceMixin):\n\"\"\"Exponential distribution.\n    Args:\n        lam: rate parameter\n    \"\"\"\nlam: NUMERIC\n@property\ndef dist(self):\nreturn stats.expon(scale=self.lam)\ndef __mul__(self, other):\nreturn Gamma(alpha=other, beta=1 / self.lam)\n__rmul__ = __mul__\n</code></pre>"},{"location":"distributions/#conjugate.distributions.Gamma","title":"<code>Gamma</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ContinuousPlotDistMixin</code>, <code>SliceMixin</code></p> <p>Gamma distribution.</p> <p>Gamma Distribution Scipy Docmentation</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>NUMERIC</code> <p>shape parameter</p> required <code>beta</code> <code>NUMERIC</code> <p>rate parameter</p> required Source code in <code>conjugate/distributions.py</code> <pre><code>@dataclass\nclass Gamma(ContinuousPlotDistMixin, SliceMixin):\n\"\"\"Gamma distribution.\n    &lt;a href=https://en.wikipedia.org/wiki/Gamma_distribution&gt;Gamma Distribution&lt;/a&gt;\n    &lt;a href=https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gamma.html&gt;Scipy Docmentation&lt;/a&gt;\n    Args:\n        alpha: shape parameter\n        beta: rate parameter\n    \"\"\"\nalpha: NUMERIC\nbeta: NUMERIC\n@property\ndef dist(self):\nreturn stats.gamma(a=self.alpha, scale=1 / self.beta)\ndef __mul__(self, other):\nreturn Gamma(alpha=self.alpha * other, beta=self.beta)\n__rmul__ = __mul__\n</code></pre>"},{"location":"distributions/#conjugate.distributions.Geometric","title":"<code>Geometric</code>  <code>dataclass</code>","text":"<p>             Bases: <code>DiscretePlotMixin</code>, <code>SliceMixin</code></p> <p>Geometric distribution.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>NUMERIC</code> <p>probability of success</p> required Source code in <code>conjugate/distributions.py</code> <pre><code>@dataclass\nclass Geometric(DiscretePlotMixin, SliceMixin):\n\"\"\"Geometric distribution.\n    Args:\n        p: probability of success\n    \"\"\"\np: NUMERIC\n@property\ndef dist(self):\nreturn stats.geom(self.p)\n</code></pre>"},{"location":"distributions/#conjugate.distributions.NegativeBinomial","title":"<code>NegativeBinomial</code>  <code>dataclass</code>","text":"<p>             Bases: <code>DiscretePlotMixin</code>, <code>SliceMixin</code></p> <p>Negative binomial distribution.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>NUMERIC</code> <p>number of successes</p> required <code>p</code> <code>NUMERIC</code> <p>probability of success</p> required Source code in <code>conjugate/distributions.py</code> <pre><code>@dataclass\nclass NegativeBinomial(DiscretePlotMixin, SliceMixin):\n\"\"\"Negative binomial distribution.\n    Args:\n        n: number of successes\n        p: probability of success\n    \"\"\"\nn: NUMERIC\np: NUMERIC\n@property\ndef dist(self):\nreturn stats.nbinom(n=self.n, p=self.p)\ndef __mul__(self, other):\nreturn NegativeBinomial(n=self.n * other, p=self.p)\n__rmul__ = __mul__\n</code></pre>"},{"location":"distributions/#conjugate.distributions.Normal","title":"<code>Normal</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ContinuousPlotDistMixin</code>, <code>SliceMixin</code></p> <p>Normal distribution.</p> <p>Parameters:</p> Name Type Description Default <code>mu</code> <code>NUMERIC</code> <p>mean</p> required <code>sigma</code> <code>NUMERIC</code> <p>standard deviation</p> required Source code in <code>conjugate/distributions.py</code> <pre><code>@dataclass\nclass Normal(ContinuousPlotDistMixin, SliceMixin):\n\"\"\"Normal distribution.\n    Args:\n        mu: mean\n        sigma: standard deviation\n    \"\"\"\nmu: NUMERIC\nsigma: NUMERIC\n@property\ndef dist(self):\nreturn stats.norm(self.mu, self.sigma)\ndef __mul__(self, other):\nsigma = ((self.sigma**2) * other) ** 0.5\nreturn Normal(mu=self.mu * other, sigma=sigma)\n__rmul__ = __mul__\n</code></pre>"},{"location":"distributions/#conjugate.distributions.NormalInverseGamma","title":"<code>NormalInverseGamma</code>  <code>dataclass</code>","text":"<p>Normal inverse gamma distribution.</p> Source code in <code>conjugate/distributions.py</code> <pre><code>@dataclass\nclass NormalInverseGamma:\n\"\"\"Normal inverse gamma distribution.\"\"\"\nmu: NUMERIC\ndelta_inverse: NUMERIC\nalpha: NUMERIC\nbeta: NUMERIC\ndef sample_sigma(self, size: int) -&gt; NUMERIC:\n\"\"\"Sample sigma from the inverse gamma distribution.\n        Args:\n            size: number of samples\n        Returns:\n            sigma: samples from the inverse gamma distribution\n        \"\"\"\nreturn 1 / stats.gamma(a=self.alpha, scale=1 / self.beta).rvs(size=size)\ndef sample_beta(\nself, size: int, return_sigma: bool = False\n) -&gt; Union[NUMERIC, Tuple[NUMERIC, NUMERIC]]:\n\"\"\"Sample beta from the normal distribution.\n        Args:\n            size: number of samples\n            return_sigma: whether to return sigma as well\n        Returns:\n            samples from the normal distribution and optionally sigma\n        \"\"\"\nsigma = self.sample_sigma(size=size)\nbeta = np.stack(\n[\nstats.multivariate_normal(self.mu, s * self.delta_inverse).rvs(size=1)\nfor s in sigma\n]\n)\nif return_sigma:\nreturn beta, sigma\nreturn beta\n</code></pre>"},{"location":"distributions/#conjugate.distributions.NormalInverseGamma.sample_beta","title":"<code>sample_beta(size, return_sigma=False)</code>","text":"<p>Sample beta from the normal distribution.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>number of samples</p> required <code>return_sigma</code> <code>bool</code> <p>whether to return sigma as well</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[NUMERIC, Tuple[NUMERIC, NUMERIC]]</code> <p>samples from the normal distribution and optionally sigma</p> Source code in <code>conjugate/distributions.py</code> <pre><code>def sample_beta(\nself, size: int, return_sigma: bool = False\n) -&gt; Union[NUMERIC, Tuple[NUMERIC, NUMERIC]]:\n\"\"\"Sample beta from the normal distribution.\n    Args:\n        size: number of samples\n        return_sigma: whether to return sigma as well\n    Returns:\n        samples from the normal distribution and optionally sigma\n    \"\"\"\nsigma = self.sample_sigma(size=size)\nbeta = np.stack(\n[\nstats.multivariate_normal(self.mu, s * self.delta_inverse).rvs(size=1)\nfor s in sigma\n]\n)\nif return_sigma:\nreturn beta, sigma\nreturn beta\n</code></pre>"},{"location":"distributions/#conjugate.distributions.NormalInverseGamma.sample_sigma","title":"<code>sample_sigma(size)</code>","text":"<p>Sample sigma from the inverse gamma distribution.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>number of samples</p> required <p>Returns:</p> Name Type Description <code>sigma</code> <code>NUMERIC</code> <p>samples from the inverse gamma distribution</p> Source code in <code>conjugate/distributions.py</code> <pre><code>def sample_sigma(self, size: int) -&gt; NUMERIC:\n\"\"\"Sample sigma from the inverse gamma distribution.\n    Args:\n        size: number of samples\n    Returns:\n        sigma: samples from the inverse gamma distribution\n    \"\"\"\nreturn 1 / stats.gamma(a=self.alpha, scale=1 / self.beta).rvs(size=size)\n</code></pre>"},{"location":"distributions/#conjugate.distributions.Poisson","title":"<code>Poisson</code>  <code>dataclass</code>","text":"<p>             Bases: <code>DiscretePlotMixin</code>, <code>SliceMixin</code></p> <p>Poisson distribution.</p> <p>Parameters:</p> Name Type Description Default <code>lam</code> <code>NUMERIC</code> <p>rate parameter</p> required Source code in <code>conjugate/distributions.py</code> <pre><code>@dataclass\nclass Poisson(DiscretePlotMixin, SliceMixin):\n\"\"\"Poisson distribution.\n    Args:\n        lam: rate parameter\n    \"\"\"\nlam: NUMERIC\n@property\ndef dist(self):\nreturn stats.poisson(self.lam)\ndef __mul__(self, other) -&gt; \"Poisson\":\nreturn Poisson(lam=self.lam * other)\n__rmul__ = __mul__\ndef __add__(self, other) -&gt; \"Poisson\":\nreturn Poisson(self.lam + other.lam)\n__radd__ = __add__\n</code></pre>"},{"location":"distributions/#conjugate.distributions.Uniform","title":"<code>Uniform</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ContinuousPlotDistMixin</code>, <code>SliceMixin</code></p> <p>Uniform distribution.</p> <p>Parameters:</p> Name Type Description Default <code>low</code> <code>NUMERIC</code> <p>lower bound</p> required <code>high</code> <code>NUMERIC</code> <p>upper bound</p> required Source code in <code>conjugate/distributions.py</code> <pre><code>@dataclass\nclass Uniform(ContinuousPlotDistMixin, SliceMixin):\n\"\"\"Uniform distribution.\n    Args:\n        low: lower bound\n        high: upper bound\n    \"\"\"\nlow: NUMERIC\nhigh: NUMERIC\ndef __post_init__(self):\nself.min_value = self.low\nself.max_value = self.high\n@property\ndef dist(self):\nreturn stats.uniform(self.low, self.high)\n</code></pre>"},{"location":"mixins/","title":"Mixins","text":"<p>Two sets of mixins to support the plotting and slicing of the distribution parameters</p>"},{"location":"mixins/#conjugate.plot.ContinuousPlotDistMixin","title":"<code>ContinuousPlotDistMixin</code>","text":"<p>             Bases: <code>PlotDistMixin</code></p> <p>Functionality for plot_pdf method of continuous distributions.</p> Source code in <code>conjugate/plot.py</code> <pre><code>class ContinuousPlotDistMixin(PlotDistMixin):\n\"\"\"Functionality for plot_pdf method of continuous distributions.\"\"\"\ndef plot_pdf(self, ax: Optional[plt.Axes] = None, **kwargs) -&gt; plt.Axes:\n\"\"\"Plot the pdf of distribution\n        Args:\n            ax: matplotlib Axes, optional\n            **kwargs: Additonal kwargs to pass to matplotlib\n        Returns:\n            new or modified Axes\n        \"\"\"\nax = self._settle_axis(ax=ax)\nx = self._create_x_values()\nx = self._reshape_x_values(x)\nreturn self._create_plot_on_axis(x, ax, **kwargs)\ndef _create_x_values(self) -&gt; np.ndarray:\nreturn np.linspace(self.min_value, self.max_value, 100)\ndef _setup_labels(self, ax) -&gt; None:\nax.set_xlabel(\"Domain\")\nax.set_ylabel(\"Density $f(x)$\")\ndef _create_plot_on_axis(self, x, ax, **kwargs) -&gt; plt.Axes:\nyy = self.dist.pdf(x)\nif \"label\" in kwargs:\nlabel = kwargs.pop(\"label\")\nlabel = resolve_label(label, yy)\nelse:\nlabel = None\nax.plot(x, yy, label=label, **kwargs)\nself._setup_labels(ax=ax)\nax.set_ylim(0, None)\nreturn ax\n</code></pre>"},{"location":"mixins/#conjugate.plot.ContinuousPlotDistMixin.plot_pdf","title":"<code>plot_pdf(ax=None, **kwargs)</code>","text":"<p>Plot the pdf of distribution</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Optional[matplotlib.Axes]</code> <p>matplotlib Axes, optional</p> <code>None</code> <code>**kwargs</code> <p>Additonal kwargs to pass to matplotlib</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>new or modified Axes</p> Source code in <code>conjugate/plot.py</code> <pre><code>def plot_pdf(self, ax: Optional[plt.Axes] = None, **kwargs) -&gt; plt.Axes:\n\"\"\"Plot the pdf of distribution\n    Args:\n        ax: matplotlib Axes, optional\n        **kwargs: Additonal kwargs to pass to matplotlib\n    Returns:\n        new or modified Axes\n    \"\"\"\nax = self._settle_axis(ax=ax)\nx = self._create_x_values()\nx = self._reshape_x_values(x)\nreturn self._create_plot_on_axis(x, ax, **kwargs)\n</code></pre>"},{"location":"mixins/#conjugate.plot.DirichletPlotDistMixin","title":"<code>DirichletPlotDistMixin</code>","text":"<p>             Bases: <code>ContinuousPlotDistMixin</code></p> <p>Plot the pdf using samples from the dirichlet distribution.</p> Source code in <code>conjugate/plot.py</code> <pre><code>class DirichletPlotDistMixin(ContinuousPlotDistMixin):\n\"\"\"Plot the pdf using samples from the dirichlet distribution.\"\"\"\ndef plot_pdf(\nself, ax: Optional[plt.Axes] = None, samples: int = 1_000, **kwargs\n) -&gt; plt.Axes:\n\"\"\"Plots the pdf\"\"\"\ndistribution_samples = self.dist.rvs(size=samples)\nax = self._settle_axis(ax=ax)\nxx = self._create_x_values()\nfor x in distribution_samples.T:\nkde = gaussian_kde(x)\nyy = kde(xx)\nax.plot(xx, yy, **kwargs)\nself._setup_labels(ax=ax)\nreturn ax\n</code></pre>"},{"location":"mixins/#conjugate.plot.DirichletPlotDistMixin.plot_pdf","title":"<code>plot_pdf(ax=None, samples=1000, **kwargs)</code>","text":"<p>Plots the pdf</p> Source code in <code>conjugate/plot.py</code> <pre><code>def plot_pdf(\nself, ax: Optional[plt.Axes] = None, samples: int = 1_000, **kwargs\n) -&gt; plt.Axes:\n\"\"\"Plots the pdf\"\"\"\ndistribution_samples = self.dist.rvs(size=samples)\nax = self._settle_axis(ax=ax)\nxx = self._create_x_values()\nfor x in distribution_samples.T:\nkde = gaussian_kde(x)\nyy = kde(xx)\nax.plot(xx, yy, **kwargs)\nself._setup_labels(ax=ax)\nreturn ax\n</code></pre>"},{"location":"mixins/#conjugate.plot.DiscretePlotMixin","title":"<code>DiscretePlotMixin</code>","text":"<p>             Bases: <code>PlotDistMixin</code></p> <p>Adding the plot_pmf method to class.</p> Source code in <code>conjugate/plot.py</code> <pre><code>class DiscretePlotMixin(PlotDistMixin):\n\"\"\"Adding the plot_pmf method to class.\"\"\"\ndef plot_pmf(\nself, ax: Optional[plt.Axes] = None, mark: str = \"o-\", **kwargs\n) -&gt; plt.Axes:\nax = self._settle_axis(ax=ax)\nx = self._create_x_values()\nx = self._reshape_x_values(x)\nreturn self._create_plot_on_axis(x, ax, mark, **kwargs)\ndef _create_x_values(self) -&gt; np.ndarray:\nreturn np.arange(self.min_value, self.max_value + 1, 1)\ndef _create_plot_on_axis(\nself, x, ax, mark, conditional: bool = False, **kwargs\n) -&gt; plt.Axes:\nyy = self.dist.pmf(x)\nif conditional:\nyy = yy / np.sum(yy)\nylabel = f\"Conditional Probability $f(x|{self.min_value} \\\\leq x \\\\leq {self.max_value})$\"\nelse:\nylabel = \"Probability $f(x)$\"\nif \"label\" in kwargs:\nlabel = kwargs.pop(\"label\")\nlabel = resolve_label(label, yy)\nelse:\nlabel = None\nax.plot(x, yy, mark, label=label, **kwargs)\nif self.max_value - self.min_value &lt; 15:\nax.set_xticks(x.ravel())\nelse:\nax.set_xticks(x.ravel(), minor=True)\nax.set_xticks(x[::5].ravel())\nax.set_xlabel(\"Domain\")\nax.set_ylabel(ylabel)\nax.set_ylim(0, None)\nreturn ax\n</code></pre>"},{"location":"mixins/#conjugate.plot.PlotDistMixin","title":"<code>PlotDistMixin</code>","text":"<p>Base mixin in order to support plotting. Requires the dist attribute of the scipy distribution.</p> Source code in <code>conjugate/plot.py</code> <pre><code>class PlotDistMixin:\n\"\"\"Base mixin in order to support plotting. Requires the dist attribute of the scipy distribution.\"\"\"\n@property\ndef dist(self) -&gt; Distribution:\nraise NotImplementedError(\"Implement this property in the subclass.\")\n@property\ndef max_value(self) -&gt; float:\nif not hasattr(self, \"_max_value\"):\nraise ValueError(\"Set the max value before plotting.\")\nreturn self._max_value\n@max_value.setter\ndef max_value(self, value: float) -&gt; None:\nself._max_value = value\ndef set_max_value(self, value: float) -&gt; \"PlotDistMixin\":\nself.max_value = value\nreturn self\n@property\ndef min_value(self) -&gt; float:\nif not hasattr(self, \"_min_value\"):\nself._min_value = 0.0\nreturn self._min_value\n@min_value.setter\ndef min_value(self, value: float) -&gt; None:\nself._min_value = value\ndef set_min_value(self, value: float) -&gt; \"PlotDistMixin\":\n\"\"\"Set the minimum value for plotting.\"\"\"\nself.min_value = value\nreturn self\ndef set_bounds(self, lower: float, upper: float) -&gt; \"PlotDistMixin\":\n\"\"\"Set both the min and max values for plotting.\"\"\"\nreturn self.set_min_value(lower).set_max_value(upper)\ndef _reshape_x_values(self, x: np.ndarray) -&gt; np.ndarray:\n\"\"\"Make sure that the values are ready for plotting.\"\"\"\nfor value in asdict(self).values():\nif not isinstance(value, float):\nreturn x[:, None]\nreturn x\ndef _settle_axis(self, ax: Optional[plt.Axes] = None) -&gt; plt.Axes:\nreturn ax if ax is not None else plt.gca()\n</code></pre>"},{"location":"mixins/#conjugate.plot.PlotDistMixin.set_bounds","title":"<code>set_bounds(lower, upper)</code>","text":"<p>Set both the min and max values for plotting.</p> Source code in <code>conjugate/plot.py</code> <pre><code>def set_bounds(self, lower: float, upper: float) -&gt; \"PlotDistMixin\":\n\"\"\"Set both the min and max values for plotting.\"\"\"\nreturn self.set_min_value(lower).set_max_value(upper)\n</code></pre>"},{"location":"mixins/#conjugate.plot.PlotDistMixin.set_min_value","title":"<code>set_min_value(value)</code>","text":"<p>Set the minimum value for plotting.</p> Source code in <code>conjugate/plot.py</code> <pre><code>def set_min_value(self, value: float) -&gt; \"PlotDistMixin\":\n\"\"\"Set the minimum value for plotting.\"\"\"\nself.min_value = value\nreturn self\n</code></pre>"},{"location":"mixins/#conjugate.plot.resolve_label","title":"<code>resolve_label(label, yy)</code>","text":"<p>https://stackoverflow.com/questions/73662931/matplotlib-plot-a-numpy-array-as-many-lines-with-a-single-label</p> Source code in <code>conjugate/plot.py</code> <pre><code>def resolve_label(label: LABEL_INPUT, yy: np.ndarray):\n\"\"\"\n    https://stackoverflow.com/questions/73662931/matplotlib-plot-a-numpy-array-as-many-lines-with-a-single-label\n    \"\"\"\nif yy.ndim == 1:\nreturn label\nncols = yy.shape[1]\nif ncols != 1:\nif isinstance(label, str):\nreturn [f\"{label} {i}\" for i in range(1, ncols + 1)]\nif callable(label):\nreturn [label(i) for i in range(ncols)]\nif isinstance(label, Iterable):\nreturn label\nraise ValueError(\"Label must be a string, iterable, or callable.\")\nreturn label\n</code></pre>"},{"location":"mixins/#conjugate.slice.SliceMixin","title":"<code>SliceMixin</code>","text":"<p>Mixin in order to slice the parameters</p> Source code in <code>conjugate/slice.py</code> <pre><code>class SliceMixin:\n\"\"\"Mixin in order to slice the parameters\"\"\"\ndef __getitem__(self, key):\nparams = asdict(self)\ndef slice(value, key):\ntry:\nreturn value[key]\nexcept Exception:\nreturn value\nnew_params = {k: slice(value=v, key=key) for k, v in params.items()}\nreturn self.__class__(**new_params)\n</code></pre>"},{"location":"models/","title":"Models","text":"<p>For more on these models, check out the Conjugate Prior Wikipedia Table</p> <p>Below are the supported models</p>"},{"location":"models/#conjugate.models.binomial_beta","title":"<code>binomial_beta(n, x, beta_prior)</code>","text":"<p>Posterior distribution for a binomial likelihood with a beta prior.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>NUMERIC</code> <p>total number of trials</p> required <code>x</code> <code>NUMERIC</code> <p>sucesses from that trials</p> required <code>beta_prior</code> <code>Beta</code> <p>Beta distribution prior</p> required <p>Returns:</p> Type Description <code>Beta</code> <p>Beta distribution posterior</p> Source code in <code>conjugate/models.py</code> <pre><code>def binomial_beta(n: NUMERIC, x: NUMERIC, beta_prior: Beta) -&gt; Beta:\n\"\"\"Posterior distribution for a binomial likelihood with a beta prior.\n    Args:\n        n: total number of trials\n        x: sucesses from that trials\n        beta_prior: Beta distribution prior\n    Returns:\n        Beta distribution posterior\n    \"\"\"\nalpha_post, beta_post = get_binomial_beta_posterior_params(\nbeta_prior.alpha, beta_prior.beta, n, x\n)\nreturn Beta(alpha=alpha_post, beta=beta_post)\n</code></pre>"},{"location":"models/#conjugate.models.binomial_beta_posterior_predictive","title":"<code>binomial_beta_posterior_predictive(n, beta)</code>","text":"<p>Posterior predictive distribution for a binomial likelihood with a beta prior.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>NUMERIC</code> <p>number of trials</p> required <code>beta</code> <code>Beta</code> <p>Beta distribution</p> required <p>Returns:</p> Type Description <code>BetaBinomial</code> <p>BetaBinomial posterior predictive distribution</p> Source code in <code>conjugate/models.py</code> <pre><code>def binomial_beta_posterior_predictive(n: NUMERIC, beta: Beta) -&gt; BetaBinomial:\n\"\"\"Posterior predictive distribution for a binomial likelihood with a beta prior.\n    Args:\n        n: number of trials\n        beta: Beta distribution\n    Returns:\n        BetaBinomial posterior predictive distribution\n    \"\"\"\nreturn BetaBinomial(n=n, alpha=beta.alpha, beta=beta.beta)\n</code></pre>"},{"location":"models/#conjugate.models.categorical_dirichlet","title":"<code>categorical_dirichlet(x, dirichlet_prior)</code>","text":"<p>Posterior distribution of Categorical model with Dirichlet prior.</p> Source code in <code>conjugate/models.py</code> <pre><code>def categorical_dirichlet(x: NUMERIC, dirichlet_prior: Dirichlet) -&gt; Dirichlet:\n\"\"\"Posterior distribution of Categorical model with Dirichlet prior.\"\"\"\nalpha_post = get_dirichlet_posterior_params(dirichlet_prior.alpha, x)\nreturn Dirichlet(alpha=alpha_post)\n</code></pre>"},{"location":"models/#conjugate.models.exponetial_gamma","title":"<code>exponetial_gamma(x_total, n, gamma_prior)</code>","text":"<p>Posterior distribution for an exponential likelihood with a gamma prior</p> Source code in <code>conjugate/models.py</code> <pre><code>def exponetial_gamma(x_total: NUMERIC, n: NUMERIC, gamma_prior: Gamma) -&gt; Gamma:\n\"\"\"Posterior distribution for an exponential likelihood with a gamma prior\"\"\"\nalpha_post, beta_post = get_exponential_gamma_posterior_params(\nalpha=gamma_prior.alpha, beta=gamma_prior.beta, x_total=x_total, n=n\n)\nreturn Gamma(alpha=alpha_post, beta=beta_post)\n</code></pre>"},{"location":"models/#conjugate.models.geometric_beta","title":"<code>geometric_beta(x_total, n, beta_prior, one_start=True)</code>","text":"<p>Posterior distribution for a geometric likelihood with a beta prior.</p> <p>Parameters:</p> Name Type Description Default <code>x_total</code> <p>sum of all trials outcomes</p> required <code>n</code> <p>total number of trials</p> required <code>beta_prior</code> <code>Beta</code> <p>Beta distribution prior</p> required <code>one_start</code> <code>bool</code> <p>whether to outcomes start at 1, defaults to True. False is 0 start.</p> <code>True</code> <p>Returns:</p> Type Description <code>Beta</code> <p>Beta distribution posterior</p> Source code in <code>conjugate/models.py</code> <pre><code>def geometric_beta(x_total, n, beta_prior: Beta, one_start: bool = True) -&gt; Beta:\n\"\"\"Posterior distribution for a geometric likelihood with a beta prior.\n    Args:\n        x_total: sum of all trials outcomes\n        n: total number of trials\n        beta_prior: Beta distribution prior\n        one_start: whether to outcomes start at 1, defaults to True. False is 0 start.\n    Returns:\n        Beta distribution posterior\n    \"\"\"\nalpha_post = beta_prior.alpha + n\nbeta_post = beta_prior.beta + x_total\nif one_start:\nbeta_post = beta_post - n\nreturn Beta(alpha=alpha_post, beta=beta_post)\n</code></pre>"},{"location":"models/#conjugate.models.linear_regression","title":"<code>linear_regression(X, y, normal_inverse_gamma_prior, inv=np.linalg.inv)</code>","text":"<p>Posterior distribution for a linear regression model with a normal inverse gamma prior.</p> <p>Derivation taken from this blog here.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>NUMERIC</code> <p>design matrix</p> required <code>y</code> <code>NUMERIC</code> <p>response vector</p> required <code>normal_inverse_gamma_prior</code> <code>NormalInverseGamma</code> <p>NormalInverseGamma prior</p> required <code>inv</code> <p>function to invert matrix, defaults to np.linalg.inv</p> <code>inv</code> <p>Returns:</p> Type Description <code>NormalInverseGamma</code> <p>NormalInverseGamma posterior distribution</p> Source code in <code>conjugate/models.py</code> <pre><code>def linear_regression(\nX: NUMERIC,\ny: NUMERIC,\nnormal_inverse_gamma_prior: NormalInverseGamma,\ninv=np.linalg.inv,\n) -&gt; NormalInverseGamma:\n\"\"\"Posterior distribution for a linear regression model with a normal inverse gamma prior.\n    Derivation taken from this blog [here](https://gregorygundersen.com/blog/2020/02/04/bayesian-linear-regression/).\n    Args:\n        X: design matrix\n        y: response vector\n        normal_inverse_gamma_prior: NormalInverseGamma prior\n        inv: function to invert matrix, defaults to np.linalg.inv\n    Returns:\n        NormalInverseGamma posterior distribution\n    \"\"\"\nN = X.shape[0]\ndelta = inv(normal_inverse_gamma_prior.delta_inverse)\ndelta_post = (X.T @ X) + delta\ndelta_post_inverse = inv(delta_post)\nmu_post = (\n# (B, B)\ndelta_post_inverse\n# (B, 1)\n# (B, B) * (B, 1) +  (B, N) * (N, 1)\n@ (delta @ normal_inverse_gamma_prior.mu + X.T @ y)\n)\nalpha_post = normal_inverse_gamma_prior.alpha + (0.5 * N)\nbeta_post = normal_inverse_gamma_prior.beta + (\n0.5\n* (\n(y.T @ y)\n# (1, B) * (B, B) * (B, 1)\n+ (normal_inverse_gamma_prior.mu.T @ delta @ normal_inverse_gamma_prior.mu)\n# (1, B) * (B, B) * (B, 1)\n- (mu_post.T @ delta_post @ mu_post)\n)\n)\nreturn NormalInverseGamma(\nmu=mu_post, delta_inverse=delta_post_inverse, alpha=alpha_post, beta=beta_post\n)\n</code></pre>"},{"location":"models/#conjugate.models.multinomial_dirichlet","title":"<code>multinomial_dirichlet(x, dirichlet_prior)</code>","text":"<p>Posterior distribution of Multinomial model with Dirichlet prior.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NUMERIC</code> <p>counts</p> required <code>dirichlet_prior</code> <code>Dirichlet</code> <p>Dirichlet prior on the counts</p> required <p>Returns:</p> Type Description <code>Dirichlet</code> <p>Dirichlet posterior distribution</p> Source code in <code>conjugate/models.py</code> <pre><code>def multinomial_dirichlet(x: NUMERIC, dirichlet_prior: Dirichlet) -&gt; Dirichlet:\n\"\"\"Posterior distribution of Multinomial model with Dirichlet prior.\n    Args:\n        x: counts\n        dirichlet_prior: Dirichlet prior on the counts\n    Returns:\n        Dirichlet posterior distribution\n    \"\"\"\nalpha_post = get_dirichlet_posterior_params(dirichlet_prior.alpha, x)\nreturn Dirichlet(alpha=alpha_post)\n</code></pre>"},{"location":"models/#conjugate.models.negative_binomial_beta","title":"<code>negative_binomial_beta(r, n, x, beta_prior)</code>","text":"<p>Posterior distribution for a negative binomial likelihood with a beta prior.</p> Source code in <code>conjugate/models.py</code> <pre><code>def negative_binomial_beta(r, n, x, beta_prior: Beta) -&gt; Beta:\n\"\"\"Posterior distribution for a negative binomial likelihood with a beta prior.\n    Args:\n    \"\"\"\nalpha_post = beta_prior.alpha + (r * n)\nbeta_post = beta_prior.beta + x\nreturn Beta(alpha=alpha_post, beta=beta_post)\n</code></pre>"},{"location":"models/#conjugate.models.negative_binomial_beta_posterior_predictive","title":"<code>negative_binomial_beta_posterior_predictive(r, beta)</code>","text":"<p>Posterior predictive distribution for a negative binomial likelihood with a beta prior</p> Source code in <code>conjugate/models.py</code> <pre><code>def negative_binomial_beta_posterior_predictive(r, beta: Beta) -&gt; BetaNegativeBinomial:\n\"\"\"Posterior predictive distribution for a negative binomial likelihood with a beta prior\"\"\"\nreturn BetaNegativeBinomial(r=r, alpha=beta.alpha, beta=beta.beta)\n</code></pre>"},{"location":"models/#conjugate.models.poisson_gamma","title":"<code>poisson_gamma(x_total, n, gamma_prior)</code>","text":"<p>Posterior distribution for a poisson likelihood with a gamma prior</p> Source code in <code>conjugate/models.py</code> <pre><code>def poisson_gamma(x_total: NUMERIC, n: NUMERIC, gamma_prior: Gamma) -&gt; Gamma:\n\"\"\"Posterior distribution for a poisson likelihood with a gamma prior\"\"\"\nalpha_post, beta_post = get_poisson_gamma_posterior_params(\nalpha=gamma_prior.alpha, beta=gamma_prior.beta, x_total=x_total, n=n\n)\nreturn Gamma(alpha=alpha_post, beta=beta_post)\n</code></pre>"},{"location":"models/#conjugate.models.poisson_gamma_posterior_predictive","title":"<code>poisson_gamma_posterior_predictive(gamma, n=1)</code>","text":"<p>Posterior predictive distribution for a poisson likelihood with a gamma prior</p> <p>Parameters:</p> Name Type Description Default <code>gamma</code> <code>Gamma</code> <p>Gamma distribution</p> required <code>n</code> <code>NUMERIC</code> <p>Number of trials for each sample, defaults to 1. Can be used to scale the distributions to a different unit of time.</p> <code>1</code> <p>Returns:</p> Type Description <code>NegativeBinomial</code> <p>NegativeBinomial distribution related to posterior predictive</p> Source code in <code>conjugate/models.py</code> <pre><code>def poisson_gamma_posterior_predictive(\ngamma: Gamma, n: NUMERIC = 1\n) -&gt; NegativeBinomial:\n\"\"\"Posterior predictive distribution for a poisson likelihood with a gamma prior\n    Args:\n        gamma: Gamma distribution\n        n: Number of trials for each sample, defaults to 1.\n            Can be used to scale the distributions to a different unit of time.\n    Returns:\n        NegativeBinomial distribution related to posterior predictive\n    \"\"\"\nn = n * gamma.alpha\np = gamma.beta / (1 + gamma.beta)\nreturn NegativeBinomial(n=n, p=p)\n</code></pre>"},{"location":"examples/binomial/","title":"Binomial Model","text":"<pre><code>from conjugate.distributions import Beta, Binomial, BetaBinomial\nfrom conjugate.models import binomial_beta, binomial_beta_posterior_predictive\nimport matplotlib.pyplot as plt\nN = 10\ntrue_dist = Binomial(n=N, p=0.5)\n# Observed Data\nX = true_dist.dist.rvs(size=1, random_state=42)\n# Conjugate prior\nprior = Beta(alpha=1, beta=1)\nposterior: Beta = binomial_beta(n=N, x=X, beta_prior=prior)\n# Comparison\nprior_predictive: BetaBinomial = binomial_beta_posterior_predictive(n=N, beta=prior)\nposterior_predictive: BetaBinomial = binomial_beta_posterior_predictive(n=N, beta=posterior)\n# Figure \nfig, axes = plt.subplots(ncols=2, nrows=1, figsize=(8, 4))\nax: plt.Axes = axes[0]\nposterior.plot_pdf(ax=ax, label=\"posterior\")\nprior.plot_pdf(ax=ax, label=\"prior\")\nax.axvline(x=X/N, color=\"black\", ymax=0.05, label=\"MLE\")\nax.axvline(x=true_dist.p, color=\"black\", ymax=0.05, linestyle=\"--\", label=\"True\")\nax.set_title(\"Success Rate\")\nax.legend()\nax: plt.Axes = axes[1]\ntrue_dist.plot_pmf(ax=ax, label=\"true distribution\", color=\"C2\")\nposterior_predictive.plot_pmf(ax=ax, label=\"posterior predictive\")\nprior_predictive.plot_pmf(ax=ax, label=\"prior predictive\")\nax.axvline(x=X, color=\"black\", ymax=0.05, label=\"Sample\")\nax.set_title(\"Number of Successes\")\nax.legend()\nplt.show()\n</code></pre>"},{"location":"examples/generalized-inputs/","title":"Generalized Numerical Inputs","text":"<p>Though the plotting is meant for numpy and python numbers, the conjugate models work with anything that works like numbers. </p> <p>For instance, Bayesian models in SQL using the SQL Builder, PyPika</p> <pre><code>from pypika import Field \n# Columns from table in database\nN = Field(\"total\")\nX = Field(\"successes\")\n# Conjugate prior\nprior = Beta(alpha=1, beta=1)\nposterior = binomial_beta(n=N, x=X, beta_prior=prior)\nprint(\"Posterior alpha:\", posterior.alpha)\nprint(\"Posterior beta:\", posterior.beta)\n# Posterior alpha: 1+\"successes\"\n# Posterior beta: 1+\"total\"-\"successes\"\n# Priors can be fields too\nalpha = Field(\"previous_successes\") - 1\nbeta = Field(\"previous_failures\") - 1\nprior = Beta(alpha=alpha, beta=beta)\nposterior = binomial_beta(n=N, x=X, beta_prior=prior)\nprint(\"Posterior alpha:\", posterior.alpha)\nprint(\"Posterior beta:\", posterior.beta)\n# Posterior alpha: \"previous_successes\"-1+\"successes\"\n# Posterior beta: \"previous_failures\"-1+\"total\"-\"successes\"\n</code></pre> <p>Using PyMC distributions for sampling with additional uncertainty</p> <pre><code>import pymc as pm \nalpha = pm.Gamma.dist(alpha=1, beta=20)\nbeta = pm.Gamma.dist(alpha=1, beta=20)\n# Observed Data\nN = 10\nX = 4\n# Conjugate prior \nprior = Beta(alpha=alpha, beta=beta)\nposterior = binomial_beta(n=N, x=X, beta_prior=prior)\n# Reconstruct the posterior distribution with PyMC\nprior_dist = pm.Beta.dist(alpha=prior.alpha, beta=prior.beta)\nposterior_dist = pm.Beta.dist(alpha=posterior.alpha, beta=posterior.beta)\nsamples = pm.draw([alpha, beta, prior_dist, posterior_dist], draws=1000)\n</code></pre>"},{"location":"examples/indexing/","title":"Indexing Parameters","text":"<p>The distributions can be indexed for subsets. </p> <pre><code>beta = np.arange(1, 10)\nprior = Beta(alpha=1, beta=beta)\nidx = [0, 5, -1]\nprior_subset = prior[idx]\nprior_subset.plot_pdf(label = lambda i: f\"prior {i}\")\nplt.legend()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/plotting/","title":"Plotting Distributions","text":"<p>All the distributions can be plotted using the <code>plot_pdf</code> and <code>plot_pmf</code> methods. The <code>plot_pdf</code> method is used for continuous distributions and the <code>plot_pmf</code> method is used for discrete distributions.</p> <p>There is limited support for some distributions like the <code>Dirichlet</code> or those without a <code>dist</code> scipy.</p> <pre><code>from conjugate.distributions import Beta, Gamma, Normal\nimport matplotlib.pyplot as plt\nbeta = Beta(1, 1)\ngamma = Gamma(1, 1)\nnormal = Normal(0, 1)\nbound = 3\ndist = [beta, gamma, normal]\nlabels = [\"beta\", \"gamma\", \"normal\"]\nax = plt.gca()\nfor label, dist in zip(labels, dist):\ndist.set_bounds(-bound, bound).plot_pdf(label=label)\nax.legend()\nplt.show()\n</code></pre> <p></p> <p>The plotting is also supported for vectorized inputs.</p>"},{"location":"examples/pymc-sampling/","title":"Unsupported Posterior Predictive Distributions with PyMC Sampling","text":"<p>The geometric beta model posterior predictive doesn't have a common dist, but what doesn't mean the posterior predictive can be used. For instance, PyMC can be used to fill in this gap.</p> <pre><code>import pymc as pm\nfrom conjugate.distribution import Beta\nfrom conjugate.models import geometric_beta\nprior = Beta(1, 1)\nposterior: Beta = geometric_beta(x=1, n=10, beta_prior=prior)\nposterior_dist = pm.Beta.dist(alpha=posterior.alpha, beta=posterior.beta)\ngeometric_posterior_predictive = pm.Geometric.dist(posterior_dist)\nposterior_predictive_samples = pm.draw(geometric_posterior_predictive, draws=100)\n</code></pre>"},{"location":"examples/scaling-distributions/","title":"Scaling Distributions","text":"<p>Some of the distributions can be scaled by a constant factor or added together. For instance, operations with Poisson distribution represent the number of events in a given time interval. </p> <pre><code>from conjugate.distributions import Poisson\nimport matplotlib.pyplot as plt\ndaily_rate = 0.25\ndaily_pois = Poisson(lam=daily_rate)\ntwo_day_pois = daily_pois + daily_pois\nweekly_pois = 7 * daily_pois\nmax_value = 7\nax = plt.gca()\ndists = [daily_pois, two_day_pois, weekly_pois]\nbase_labels = [\"daily\", \"two day\", \"weekly\"]\nfor dist, base_label in zip(dists, base_labels):\nlabel = f\"{base_label} rate={dist.lam}\"\ndist.set_max_value(max_value).plot_pmf(ax=ax, label=label)\nax.legend()\nplt.show()\n</code></pre> <p></p> <p>The normal distribution also supports scaling making use of the fact that the variance of a scaled normal distribution is the square of the scaling factor. </p> <pre><code>from conjugate.distributions import Normal\nimport matplotlib.pyplot as plt\nnorm = Normal(mu=0, sigma=1)\nnorm_times_2 = norm * 2\nbound = 6\nax = norm.set_bounds(-bound, bound).plot_pdf(label=f\"normal (std = {norm.sigma:.2f})\")\nnorm_times_2.set_bounds(-bound, bound).plot_pdf(ax=ax, label=f\"normal * 2 (std = {norm_times_2.sigma:.2f})\")\nax.legend()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/scipy-connection/","title":"Connection to SciPy Distributions","text":"<p>Many distributions have the <code>dist</code> attribute which is a scipy.stats distribution object. From there, the methods from scipy.stats to get the pdf, cdf, etc can be leveraged.</p> <pre><code>from conjugate.distribution import Beta \nbeta = Beta(1, 1)\nscipy_dist = beta.dist \nprint(scipy_dist.mean())\n# 0.5\nprint(scipy_dist.ppf([0.025, 0.975]))\n# [0.025 0.975]\nsamples = scipy_dist.rvs(100)\n</code></pre>"},{"location":"examples/vectorized-inputs/","title":"Vectorized Inputs","text":"<p>All data and priors will allow for vectorized assuming the shapes work for broadcasting. </p> <p>The plotting also supports arrays of results</p> <pre><code>import numpy as np\nfrom conjugate.distributions import Beta\nfrom conjugate.models import binomial_beta\nimport matplotlib.pyplot as plt\n# Analytics \nprior = Beta(alpha=1, beta=np.array([1, 5]))\nposterior = binomial_beta(n=N, x=x, beta_prior=prior)\n# Figure\nax = prior.plot_pdf(label=lambda i: f\"prior {i}\")\nposterior.plot_pdf(ax=ax, label=lambda i: f\"posterior {i}\")\nax.axvline(x=x / N, ymax=0.05, color=\"black\", linestyle=\"--\", label=\"MLE\")\nax.legend()\nplt.show()\n</code></pre> <p></p>"}]}